# Tunely (musikrum) - Gemini Full Audit

## Security Audit
Som senior security auditor har jag granskat din kodbas. Applikationen har en modern arkitektur, men lider av flera kritiska s√§kerhetsbrister, fr√§mst relaterade till hur g√§stsessioner och auktorisering i API-routes hanteras.

H√§r √§r min tekniska analys:

---

### 1. Kritiska Buggar (High Risk)

#### **[9/10] Bristf√§llig Guest Authentication (Impersonation)**
*   **Problem:** `guestId` behandlas som en "hemlighet" men skickas i klartext i URL-parametrar (`/api/rooms/[id]?guestId=...`) och lagras i osignerade cookies. 
*   **S√•rbarhet:** En angripare kan enkelt gissa eller stj√§la ett `guestId` (t.ex. via webbhistorik eller logs) och utge sig f√∂r att vara den anv√§ndaren. Det finns ingen kryptografisk verifiering (likt en JWT eller session-token) att g√§sten faktiskt √§ger det ID:t.
*   **Plats:** `src/app/api/rooms/[id]/route.ts`, `src/lib/guest.ts`.
*   **√Ötg√§rd:** Skapa signerade JWT-tokens √§ven f√∂r g√§ster eller anv√§nd NextAuths "anonymous" provider-m√∂nster.

#### **[8/10] Broken Object Level Authorization (IDOR) i Reorder API**
*   **Problem:** API-routen f√∂r att √§ndra ordning i k√∂n verifierar att anv√§ndaren √§r inloggad, men **inte** att anv√§ndaren faktiskt √§r medlem i det specifika rummet.
*   **S√•rbarhet:** En inloggad anv√§ndare kan manipulera k√∂n i *vilket rum som helst* genom att skicka en PUT-request till `/api/rooms/[TARGET_ROOM_ID]/queue/[ITEM_ID]/reorder`.
*   **Plats:** `src/app/api/rooms/[id]/queue/[itemId]/reorder/route.ts`.
*   **√Ötg√§rd:** L√§gg till en kontroll: `const isMember = await prisma.roomMember.findFirst({ where: { roomId, userId: session.user.id } });` innan transaktionen k√∂rs.

#### **[7/10] Rate Limiting Bypass & Brute Force**
*   **Problem:** Viktiga endpoints saknar rate limiting.
    *   `/api/rooms/join`: Till√•ter brute-force av 5-st√§lliga rumskoder (32^5 kombinationer √§r f√∂rv√•nansv√§rt f√•).
    *   `/api/auth/signup`: Till√•ter automatiserat skapande av konton.
*   **S√•rbarhet:** Angripare kan "scanna" efter aktiva rum eller √∂verbelasta databasen med skr√§pkonton.
*   **Plats:** `src/app/api/rooms/join/route.ts`, `src/app/api/auth/signup/route.ts`.
*   **√Ötg√§rd:** Implementera `rateLimitCheck` p√• samtliga POST/PUT-routes.

---

### 2. Medium Risk

#### **[5/10] Sensitive Information Disclosure (Invite Tokens)**
*   **Problem:** Inbjudningsl√§nkar genereras som JWT i URL-queryn (`?token=...`).
*   **S√•rbarhet:** URL:er l√§cker ofta via `Referer`-headers till tredjepartstj√§nster (t.ex. Spotify-bilder eller analytics) och lagras i webbl√§sarhistorik. Om en person delar en sk√§rmbild p√• sin URL kan rummet kapas.
*   **√Ötg√§rd:** Anv√§nd korta, eng√•ngskoder som lagras i databasen ist√§llet f√∂r JWT i URL:en f√∂r permanenta inbjudningar.

#### **[4/10] Brist p√• Input Validation & Length Limits**
*   **Problem:** `trackName`, `artistName` och `displayName` valideras inte f√∂r l√§ngd.
*   **S√•rbarhet:** "Database bloat" eller UI-breaking (DoS p√• klientsidan) genom att skicka in megabyte-l√•nga str√§ngar som rumsnamn eller l√•ttitlar.
*   **√Ötg√§rd:** Anv√§nd ett bibliotek som **Zod** f√∂r att validera alla inkommande API-requests (max 100 tecken f√∂r namn, etc).

---

### 3. Best Practices & Observationer

*   **SQL Injection:** **L√•g risk.** Du anv√§nder Prisma Client vilket effektivt skyddar mot SQLi. Inga os√§kra `queryRaw` identifierades.
*   **XSS:** **L√•g risk.** Next.js/React escaperar data automatiskt. Dock b√∂r du vara f√∂rsiktig med `item.reason` om det skulle inneh√•lla anv√§ndargenererad data i framtiden.
*   **Secret Management:** Bra att du anv√§nder `.env`. Se till att `.env` aldrig checkas in och att `NEXTAUTH_SECRET` √§r en kryptografiskt stark slumpm√§ssig str√§ng i produktion.
*   **CSRF:** NextAuth har inbyggt skydd f√∂r auth-routes. F√∂r √∂vriga API-call kr√§vs `Content-Type: application/json` vilket ger ett visst skydd via CORS-preflight i moderna webbl√§sare.

---

### Sammanfattande Betyg: Security 4/10

**Audit-slutsats:**
Applikationen har en stabil grund i NextAuth och Prisma, men s√§kerhetsmodellen faller p√• den manuella hanteringen av g√§ster och IDOR-s√•rbarheter i API-lagret. 

**Prioritetslista f√∂r √•tg√§rder:**
1.  **Auktorisering:** Kontrollera medlemskap i *varje* API-route som r√∂r ett specifikt rum.
2.  **G√§st-s√§kerhet:** Signera g√§st-sessioner med en hemlighet.
3.  **Validering:** Inf√∂r Zod-schemas f√∂r alla API-inputs.
4.  **Rate Limiting:** Skydda `/join` och `/signup` omedelbart.

---

## Code Quality Audit
H√§r √§r en teknisk granskning av **Musik-app** ur ett senior-perspektiv.

### **Code Quality Rating: 7/10**
Applikationen √§r v√§lstrukturerad och anv√§nder modern Next.js-arkitektur (App Router) p√• ett korrekt s√§tt. Den har bra s√§kerhetst√§nk (Middleware, Rate limiting) och en tydlig UX-filosofi. Det som drar ner betyget √§r fr√§mst "God Component"-tendenser i frontend och ineffektiva databasfr√•gor (N+1) i backend.

---

### **Topp 5 F√∂rb√§ttringar**

1.  **Inf√∂r TanStack Query (SWR):** Ni anv√§nder manuell `useEffect` + `useState` + `refresh()` f√∂r data-fetching. Detta leder till "race conditions" och saknar cache-hantering. Genom att anv√§nda `useQuery` och `useMutation` kan ni ers√§tta manuell tillst√•ndshantering och f√• automatisk revalidering n√§r en l√•t l√§ggs till eller r√∂stas p√•.
2.  **Optimera Prisma-fr√•gor (Eliminera N+1):** I `api/rooms/[id]/generate-playlist/route.ts` k√∂rs queries i en loop f√∂r varje medlem. Detta √§r ett klassiskt N+1-problem. Anv√§nd Prismas `include` f√∂r att h√§mta medlemmar, deras anv√§ndardata och preferenser i **en** enda databasfr√•ga.
3.  **Dekomponera `RoomPage`:** `src/app/room/[id]/page.tsx` √§r en "God Component" p√• √∂ver 600 rader. Den inneh√•ller allt fr√•n Skeletons till logik f√∂r spelliste-generering. Bryt ut `PlaylistGenerator`, `TrackSearch` och `QueueList` till egna filer i en dedikerad mapp: `src/components/room/`.
4.  **Validering med Zod:** API-routerna litar blint p√• `req.json()`. Genom att anv√§nda **Zod** kan ni definiera scheman f√∂r inkommande data. Detta ger b√•de runtime-validering och automatisk TypeScript-typning av request-bodyn, vilket eliminerar `any`-typer i backend.
5.  **Centralisera Spotify-logik:** Ni har utspridd `fetch`-logik mot Spotify API:et i olika rutter. Skapa en central `SpotifyClient`-klass eller service som hanterar tokens, felmeddelanden och retries p√• ett enhetligt s√§tt.

---

### **Anti-patterns**

*   **Manuella Joins i API:** I `api/rooms/[id]/queue/route.ts` h√§mtas anv√§ndarnamn manuellt via `nameMap` efter att k√∂n h√§mtats. Detta b√∂r g√∂ras direkt i Prisma-fr√•gan via `include: { addedByUser: { select: { displayName: true } } }`.
*   **Klient-side State Duplicering:** `OnboardingPage` h√•ller flera mappar och listor i state (`selectedArtists`, `artistIdMap`, `searchResults`) som delvis √∂verlappar. Detta √∂kar risken f√∂r att UI:t blir osynkat.
*   **Inline-komponenter i filer:** Att definiera `QueueSkeleton` och `EmptyQueue` i samma fil som huvudkomponenten g√∂r koden sv√•rl√§st och motverkar √•teranv√§ndning.
*   **Avsaknad av Error Boundaries:** Om `PlaylistGenerator` kraschar drar den ner hela `RoomPage`. Anv√§nd React Error Boundaries f√∂r att isolera fel i specifika delar av UI:t.

---

### **Teknisk Djupdykning**

#### **1. TypeScript Typing**
*   **Bra:** Anv√§nder Module Augmentation f√∂r `next-auth` korrekt i `next-auth.d.ts`.
*   **Brister:** Mycket anv√§ndning av `Record<string, unknown>` och manuella casts. Skapa explicita interface f√∂r API-responser som delas mellan frontend och backend.

#### **2. Database Queries (N+1)**
**Kritiskt fel i `generate-playlist/route.ts`:**
```typescript
for (const rm of roomMembers) {
  const user = await prisma.user.findUnique(...); // N+1
  const prefs = await prisma.preference.findMany(...); // N+1
}
```
**L√∂sning:**
```typescript
const members = await prisma.roomMember.findMany({
  where: { roomId },
  include: { user: { include: { preferences: true } } }
});
```

#### **3. API Route Patterns**
*   **Bra:** Anv√§nder `rateLimitCheck` konsekvent.
*   **Bra:** Anv√§nder dynamiska rutter `[id]` och `[itemId]` enligt REST-praxis.
*   **F√∂rb√§ttring:** Konsekvent felhantering saknas. Vissa rutter returnerar `{ error: string }`, andra bara statuskoder. Skapa en `apiHandler`-wrapper.

#### **4. Performance**
*   **Debounce:** Bra implementering av debounce i `OnboardingPage` f√∂r att spara p√• Spotify API-anrop.
*   **Payload:** `RoomPage` h√§mtar mycket data vid f√∂rsta laddning. √ñverv√§g att anv√§nda Server Components f√∂r den initiala rumsdatan och Client Components endast f√∂r den interaktiva k√∂n.

#### **5. React Patterns**
*   **DND-hantering:** Bra anv√§ndning av `@dnd-kit`. Dock b√∂r `handleDragEnd` optimeras. Ist√§llet f√∂r att k√∂ra en loop med `fetch` (vilket √§r extremt l√•ngsamt), b√∂r ni skicka hela den nya ordningen i ett anrop eller anv√§nda en `position`-kolumn (Lexorank) i databasen.

---

## Feature Completeness Audit
H√§r √§r en produktutv√§rdering av **Musikrum** ur ett PM-perspektiv.

### √ñvergripande Bed√∂mning
Applikationen har en imponerande teknisk bredd f√∂r att vara en MVP. Arkitekturen adresserar de tre viktigaste pelarna f√∂r en social musikapp: **L√•g friktion** (Guest mode), **Social tillv√§xt** (V√§n-system/Inbjudningar) och **Merv√§rde** (AI-genererade spellistor baserat p√• gruppens smak).

---

### 1. Feature-analys: √Ñr det implementerat?

*   **Onboarding (Spotify-anv√§ndare):** **Fullst√§ndig.** Fl√∂det med genrer/artister och persistens i Prisma √§r solid. Kopplingen till Spotify Top API ger en bra "cold start"-upplevelse.
*   **Delad k√∂ (Voting/D&D):** **Fullst√§ndig men riskfylld.** Drag-and-drop med `@dnd-kit` √§r implementerat. R√∂stningslogiken i API:et (`votes: { increment: voteChange }`) fungerar, men sorteringen f√∂rlitar sig p√• polling var 3:e sekund, vilket kan k√§nnas "hoppigt" f√∂r anv√§ndaren n√§r listan r√∂r sig.
*   **Auto-playlist generation:** **Avancerad.** Att inkludera olika "modes" (Dinner, Party, etc.) och vikta medlemmarnas preferenser √§r appens "killer feature". Preview-funktionen innan man l√§gger till i k√∂n √§r ett moget produktbeslut.
*   **Guest Mode & Conversion:** **Exceptionell.** Detta √§r ofta d√§r appar misslyckas. Logiken att spara `guestId` i cookies och sedan erbjuda en "GuestConversionBanner" som mappar √∂ver data till ett riktigt konto √§r mycket starkt f√∂r user retention.
*   **Private Rooms:** **Fullst√§ndig.** QR-koder och JWT-baserade inbjudningsl√§nkar ger en s√§ker men enkel access.

---

### 2. UX-Gaps & Missade kopplingar

*   **Email-anv√§ndare vs Onboarding:** I `auth.ts` markeras email-anv√§ndare som `onboarded: true` direkt.
    *   *Problem:* Dessa anv√§ndare f√•r aldrig v√§lja genrer/artister, vilket g√∂r att "Auto-playlist"-funktionen inte kan ta h√§nsyn till deras smak. De blir "passiva" medlemmar i algoritmen.
*   **Playback-synkronisering:** Appen anv√§nder Spotify Web Playback SDK.
    *   *Gap:* Spotify SDK:n spelar musik p√• den *lokala* enheten. Om det √§r ett fysiskt rum d√§r en person √§r "Host" fungerar det utm√§rkt. Men om det √§r f√∂r remote-lyssning saknas en "Listen Along"-knapp eller server-synkad seek-tid.
*   **S√∂k-feedback:** I `TrackSearch` finns en spinner, men ingen "Inga resultat"-vy. Detta skapar os√§kerhet vid stavfel.
*   **Drag-and-Drop vs Votes:** Det finns en logisk konflikt. Om jag drar en l√•t till toppen (reorder), men n√•gon annan r√∂star p√• en annan l√•t, vem vinner? API:et f√∂rs√∂ker l√∂sa detta genom att "swappa" r√∂ster, men det √§r en instabil l√∂sning som kan f√∂rvirra anv√§ndare.

---

### 3. Edge Cases & Felhantering

*   **Spotify Premium-krav:** Appen hanterar detta snyggt i `MiniPlayer` genom att d√∂lja kontroller f√∂r Free-anv√§ndare, men "Export to Playlist" √§r ett genialt fallback-alternativ f√∂r dem.
*   **Token Expiry:** Middleware kollar inte om Spotify-token har g√•tt ut innan redirect till `/app`. Om `refreshAccessToken` misslyckas i bakgrunden kan anv√§ndaren landa p√• en trasig sida.
*   **Race Conditions i K√∂n:** Vid h√∂g aktivitet (m√•nga som r√∂star samtidigt) kan polling (var 3:e sek) skriva √∂ver lokala states. WebSockets (t.ex. Pusher) vore n√§sta naturliga steg.

---

### 4. Inkompletta fl√∂den

*   **V√§nf√∂rfr√•gningar f√∂r g√§ster:** Logiken finns i API:et f√∂r att skicka f√∂rfr√•gningar till g√§ster (`toGuestId`), men det finns inget gr√§nssnitt f√∂r en inloggad anv√§ndare att faktiskt "hitta" en g√§st i rummet och klicka "Add Friend" ut√∂ver den generella inbjudan.
*   **Radera rum:** Anv√§ndaren kan skapa rum, men det finns inget s√§tt att st√§nga eller radera dem i UI:t, vilket kommer leda till "rum-sprawl" i databasen.

---

### Slutsats & Betyg

Appen √§r ovanligt v√§l genomt√§nkt f√∂r att vara ett tidigt projekt. S√§rskilt fokuset p√• **Guest -> User conversion** visar p√• produktf√∂rst√•else ut√∂ver det tekniska.

**UX-Gaps:**
1.  Ge Email-anv√§ndare tillg√•ng till onboarding (eller en light-version).
2.  Byt ut polling mot WebSockets f√∂r en s√∂ml√∂s k√∂-upplevelse.
3.  Tydligg√∂r "Host"-rollen (vem styr ljudet?).

#### **Feature Completeness: 8.5 / 10**
*Motivering: Alla utlovade features finns d√§r och fungerar. Det som saknas √§r finliret i synkroniseringen och onboarding-bryggan f√∂r icke-Spotify-anv√§ndare.*

---

## Overall Score
- Security: 4/10
- Code Quality: 7/10
- Feature Completeness: 8.5/10
- **Total: 6.5/10**

## Top Priority Fixes
1. **[CRITICAL Security]** Fix Guest Authentication ‚Äî sign guest sessions with JWT/secret instead of plain guestId in URLs/cookies
2. **[CRITICAL Security]** Fix IDOR in room APIs ‚Äî verify room membership in every API route
3. **[Quality]** Eliminate N+1 queries in generate-playlist (use Prisma `include`)
4. **[Quality]** Decompose RoomPage (600+ lines) into smaller components
5. **[Feature]** Give email users access to onboarding (genre/artist selection)

## Deployment Readiness
- ‚ö†Ô∏è **NOT production-ready** ‚Äî Security score 4/10 blocks launch
- ‚úÖ MVP-ready after fixing: guest auth signing + IDOR authorization checks
- üöÄ Production recommendations:
  - Add rate limiting to /join and /signup
  - Implement Zod validation on all API inputs
  - Replace polling with WebSockets for real-time queue
  - Add input length limits (prevent DoS via oversized strings)
  - Use database-stored invite codes instead of JWT in URLs

---
*Audit ran: 2026-02-20 19:57 UTC*
*Repo: /root/clawd/repos/novastate/musik-app*
*Auditor: Gemini 2.5 Pro via Gemini CLI*
